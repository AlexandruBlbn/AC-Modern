<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>13.2.2 - Mapare DirectÄƒ</title>
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="../../css/lesson.css">
</head>
<body>
    <article class="lesson-container">
        <header class="lesson-header">
            <span class="lesson-badge">LecÈ›ia 13.2.2</span>
            <h1 class="lesson-title">Mapare DirectÄƒ</h1>
            <p class="lesson-subtitle">Cea mai simplÄƒ metodÄƒ de organizare a memoriei cache</p>
        </header>

        <section class="section" id="introducere">
            <h2 class="section-title">Ce este Maparea DirectÄƒ?</h2>
            <p class="text-content">
                <strong>Maparea directÄƒ</strong> (Direct-Mapped Cache) este cea mai simplÄƒ schemÄƒ 
                de organizare a cache-ului, Ã®n care fiecare bloc din memoria principalÄƒ poate fi 
                stocat Ã®ntr-o singurÄƒ locaÈ›ie predeterminatÄƒ Ã®n cache.
            </p>

            <div class="definition-box">
                <p class="definition-label">DefiniÈ›ie</p>
                <p class="definition-text">
                    Ãntr-un cache cu mapare directÄƒ, locaÈ›ia (indexul) Ã®n care poate fi plasat 
                    un bloc de memorie este determinatÄƒ unic de adresa acelui bloc, folosind 
                    formula: <code class="code-inline">Index = (Adresa bloc) mod (NumÄƒr linii cache)</code>
                </p>
            </div>
        </section>

        <section class="section" id="principiu">
            <h2 class="section-title">Principiul de FuncÈ›ionare</h2>
            
            <p class="text-content">
                Ãn maparea directÄƒ, adresa de memorie este Ã®mpÄƒrÈ›itÄƒ Ã®n trei cÃ¢mpuri:
            </p>

            <div class="code-block">
<pre>Exemplu: Cache 4 KB, linie 64 bytes, adresÄƒ 32 biÈ›i

Adresa (32 biÈ›i):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    TAG (20 biÈ›i) â”‚ INDEX (6 b)â”‚ OFFSET (6 b)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Calcule:
- NumÄƒr linii = 4 KB / 64 bytes = 64 linii
- BiÈ›i pentru index = logâ‚‚(64) = 6 biÈ›i
- BiÈ›i pentru offset = logâ‚‚(64) = 6 biÈ›i  
- BiÈ›i pentru tag = 32 - 6 - 6 = 20 biÈ›i</pre>
            </div>

            <div class="info-box info-blue">
                <p class="info-title">ğŸ” Exemplu de Mapare</p>
                <p>
                    Cu 64 de linii de cache, blocurile de memorie cu adresele 0, 64, 128, 192, ... 
                    toate se mapeazÄƒ la <strong>linia 0</strong>. Blocurile cu adresele 1, 65, 129, 193, ... 
                    se mapeazÄƒ la <strong>linia 1</strong>, etc.
                </p>
            </div>
        </section>

        <section class="section" id="algoritm">
            <h2 class="section-title">Algoritmul de Acces</h2>
            
            <p class="text-content">
                CÃ¢nd procesorul solicitÄƒ o adresÄƒ, cache-ul cu mapare directÄƒ executÄƒ:
            </p>

            <ol class="content-list numbered">
                <li><strong>Extrage indexul</strong> din adresÄƒ È™i selecteazÄƒ linia corespunzÄƒtoare</li>
                <li><strong>ComparÄƒ tag-ul</strong> din adresÄƒ cu tag-ul stocat Ã®n linia selectatÄƒ</li>
                <li><strong>VerificÄƒ bitul valid</strong> al liniei</li>
                <li>DacÄƒ tag-urile coincid È™i bitul valid este 1 â†’ <strong>HIT</strong></li>
                <li>Altfel â†’ <strong>MISS</strong>, aduce blocul È™i Ã®nlocuieÈ™te linia existentÄƒ</li>
            </ol>

            <div class="code-block">
<pre>// Pseudocod pentru accesul la cache cu mapare directÄƒ
function cache_access(address):
    index = extract_index(address)
    tag = extract_tag(address)
    offset = extract_offset(address)
    
    line = cache[index]
    
    if (line.valid == 1) AND (line.tag == tag):
        // CACHE HIT
        return line.data[offset]
    else:
        // CACHE MISS
        block = fetch_from_memory(address)
        line.data = block
        line.tag = tag
        line.valid = 1
        return block[offset]</pre>
            </div>
        </section>

        <section class="section" id="exemplu">
            <h2 class="section-title">Exemplu Detaliat</h2>
            
            <p class="text-content">
                SÄƒ considerÄƒm un cache cu mapare directÄƒ cu urmÄƒtoarele caracteristici:
            </p>

            <table class="data-table">
                <tr><td><strong>Dimensiune cache</strong></td><td>1 KB (1024 bytes)</td></tr>
                <tr><td><strong>Dimensiune linie</strong></td><td>16 bytes</td></tr>
                <tr><td><strong>NumÄƒr linii</strong></td><td>64 (1024 / 16)</td></tr>
                <tr><td><strong>AdresÄƒ</strong></td><td>16 biÈ›i</td></tr>
            </table>

            <p class="text-content">
                ÃmpÄƒrÈ›irea adresei:
            </p>
            <ul class="content-list">
                <li><strong>Offset:</strong> logâ‚‚(16) = 4 biÈ›i (selecteazÄƒ byte-ul Ã®n linie)</li>
                <li><strong>Index:</strong> logâ‚‚(64) = 6 biÈ›i (selecteazÄƒ linia)</li>
                <li><strong>Tag:</strong> 16 - 4 - 6 = 6 biÈ›i (identificÄƒ blocul)</li>
            </ul>

            <div class="info-box">
                <p class="info-title">ğŸ“Š SecvenÈ›Äƒ de Accesuri</p>
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Adresa (hex)</th>
                            <th>Tag</th>
                            <th>Index</th>
                            <th>Offset</th>
                            <th>Rezultat</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td>0x0000</td><td>0</td><td>0</td><td>0</td><td>Miss (cache gol)</td></tr>
                        <tr><td>0x0004</td><td>0</td><td>0</td><td>4</td><td>Hit (aceeaÈ™i linie)</td></tr>
                        <tr><td>0x0010</td><td>0</td><td>1</td><td>0</td><td>Miss (linie nouÄƒ)</td></tr>
                        <tr><td>0x0400</td><td>1</td><td>0</td><td>0</td><td>Miss (conflict, Ã®nlocuire)</td></tr>
                        <tr><td>0x0000</td><td>0</td><td>0</td><td>0</td><td>Miss (a fost Ã®nlocuit)</td></tr>
                    </tbody>
                </table>
            </div>
        </section>

        <section class="section" id="avantaje-dezavantaje">
            <h2 class="section-title">Avantaje È™i Dezavantaje</h2>

            <div class="card-grid">
                <div class="info-card">
                    <div class="card-icon">âœ…</div>
                    <h3 class="card-title">Avantaje</h3>
                    <p class="card-text">
                        â€¢ Implementare simplÄƒ È™i rapidÄƒ<br>
                        â€¢ Hardware minimal (o singurÄƒ comparaÈ›ie)<br>
                        â€¢ Timp de acces deterministic<br>
                        â€¢ Cost redus<br>
                        â€¢ Consum de energie mic
                    </p>
                </div>
                <div class="info-card">
                    <div class="card-icon">âŒ</div>
                    <h3 class="card-title">Dezavantaje</h3>
                    <p class="card-text">
                        â€¢ <strong>Conflicte frecvente</strong> (conflict misses)<br>
                        â€¢ PerformanÈ›Äƒ slabÄƒ pentru anumite pattern-uri<br>
                        â€¢ Blocuri care se mapeazÄƒ la aceeaÈ™i linie se Ã®nlocuiesc reciproc<br>
                        â€¢ Nu poate exploata toate liniile disponibile
                    </p>
                </div>
            </div>
        </section>

        <section class="section" id="conflicte">
            <h2 class="section-title">Problema Conflictelor</h2>
            
            <p class="text-content">
                Principala problemÄƒ a mapÄƒrii directe este apariÈ›ia <strong>conflict miss-urilor</strong>. 
                Acestea apar cÃ¢nd douÄƒ sau mai multe blocuri frecvent accesate se mapeazÄƒ la aceeaÈ™i linie, 
                Ã®nlocuindu-se reciproc.
            </p>

            <div class="info-box info-blue">
                <p class="info-title">ğŸ’¡ Exemplu Clasic: Thrashing</p>
                <p>
                    DacÄƒ un program acceseazÄƒ alternativ array-uri <code class="code-inline">A</code> È™i 
                    <code class="code-inline">B</code> care se mapeazÄƒ la aceeaÈ™i linie:
                </p>
                <div class="code-block">
<pre>for (i = 0; i < N; i++) {
    suma += A[i] + B[i];  // DacÄƒ A[i] È™i B[i] au acelaÈ™i index
}                          // â†’ fiecare acces e MISS!</pre>
                </div>
                <p>
                    Chiar dacÄƒ cache-ul are loc pentru ambele, ele se Ã®nlocuiesc continuu, 
                    rezultÃ¢nd 0% hit rate pentru aceste accesuri.
                </p>
            </div>

            <p class="text-content">
                SoluÈ›ia pentru conflicte este creÈ™terea <strong>asociativitÄƒÈ›ii</strong>, 
                permiÈ›Ã¢nd unui bloc sÄƒ fie stocat Ã®n mai multe locaÈ›ii posibile.
            </p>
        </section>

        <section class="section" id="sumar">
            <h2 class="section-title">Rezumat</h2>
            <div class="info-box info-green">
                <p class="info-title">ğŸ“ Puncte Cheie</p>
                <ul class="content-list">
                    <li>Maparea directÄƒ: fiecare bloc are o singurÄƒ locaÈ›ie posibilÄƒ Ã®n cache</li>
                    <li>Formula: Index = Adresa mod NumÄƒr_linii</li>
                    <li>Adresa = Tag + Index + Offset</li>
                    <li>Avantaje: simplÄƒ, rapidÄƒ, ieftinÄƒ</li>
                    <li>Dezavantaj major: conflict miss-uri cÃ¢nd blocuri diferite competÄƒ pentru aceeaÈ™i linie</li>
                </ul>
            </div>
        </section>
    </article>

    <script>
        document.querySelectorAll('.accordion-header').forEach(header => {
            header.addEventListener('click', () => {
                const content = header.nextElementSibling;
                const isExpanded = content.classList.contains('expanded');
                header.classList.toggle('active', !isExpanded);
                content.classList.toggle('expanded', !isExpanded);
            });
        });
    </script>
    <script src="../../js/lesson.js"></script>
</body>
</html>
