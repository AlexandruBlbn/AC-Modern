<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>13.2.4 - Politici de Ãnlocuire</title>
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="../../css/lesson.css">
</head>
<body>
    <article class="lesson-container">
        <header class="lesson-header">
            <span class="lesson-badge">LecÈ›ia 13.2.4</span>
            <h1 class="lesson-title">Politici de Ãnlocuire</h1>
            <p class="lesson-subtitle">Algoritmi pentru selectarea liniei de cache care va fi Ã®nlocuitÄƒ</p>
        </header>

        <section class="section" id="introducere">
            <h2 class="section-title">De ce avem nevoie de Politici de Ãnlocuire?</h2>
            <p class="text-content">
                CÃ¢nd apare un <strong>cache miss</strong> È™i trebuie adus un nou bloc Ã®n cache, 
                este necesar sÄƒ decidem ce linie existentÄƒ va fi Ã®nlocuitÄƒ. Ãn cache-urile cu mapare 
                directÄƒ, alegerea este trivialÄƒ (existÄƒ o singurÄƒ locaÈ›ie posibilÄƒ), dar Ã®n 
                cache-urile asociative, trebuie ales Ã®ntre mai multe linii candidate.
            </p>

            <div class="definition-box">
                <p class="definition-label">DefiniÈ›ie</p>
                <p class="definition-text">
                    <strong>Politica de Ã®nlocuire</strong> (replacement policy) este algoritmul 
                    care determinÄƒ care linie de cache va fi evacuatÄƒ atunci cÃ¢nd este nevoie 
                    sÄƒ se facÄƒ loc pentru un nou bloc de date.
                </p>
            </div>
        </section>

        <section class="section" id="politici">
            <h2 class="section-title">Principalele Politici de Ãnlocuire</h2>

            <div class="accordion">
                <div class="accordion-item">
                    <button class="accordion-header">
                        <span>ğŸ• LRU (Least Recently Used)</span>
                        <span class="icon-plus">+</span>
                    </button>
                    <div class="accordion-content">
                        <div class="accordion-body">
                            <p class="text-content">
                                <strong>LRU</strong> Ã®nlocuieÈ™te linia care nu a fost accesatÄƒ de cel mai mult timp. 
                                Se bazeazÄƒ pe principiul localitÄƒÈ›ii temporale: dacÄƒ o datÄƒ nu a fost accesatÄƒ recent, 
                                probabil nu va fi accesatÄƒ nici Ã®n viitorul apropiat.
                            </p>
                            
                            <table class="data-table">
                                <tr><td><strong>Avantaje</strong></td><td>PerformanÈ›Äƒ foarte bunÄƒ, exploateazÄƒ localitatea temporalÄƒ</td></tr>
                                <tr><td><strong>Dezavantaje</strong></td><td>Hardware complex pentru N mare, necesitÄƒ urmÄƒrirea ordinii accesurilor</td></tr>
                                <tr><td><strong>Utilizare</strong></td><td>Cache-uri L1/L2 cu asociativitate micÄƒ (2-8 way)</td></tr>
                            </table>

                            <div class="info-box info-blue">
                                <p class="info-title">ğŸ“Š Exemplu LRU (4-way)</p>
                                <p>
                                    Ordine accesuri: A, B, C, D, E (miss pentru E)<br>
                                    Stare Ã®nainte: [A, B, C, D] cu ordinea LRU: A < B < C < D<br>
                                    La miss pentru E, A este Ã®nlocuit (cel mai vechi accesat)<br>
                                    Stare dupÄƒ: [E, B, C, D]
                                </p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header">
                        <span>ğŸ² Random (Aleatoriu)</span>
                        <span class="icon-plus">+</span>
                    </button>
                    <div class="accordion-content">
                        <div class="accordion-body">
                            <p class="text-content">
                                <strong>Random</strong> selecteazÄƒ aleatoriu o linie pentru Ã®nlocuire, 
                                fÄƒrÄƒ a È›ine cont de istoricul accesurilor.
                            </p>
                            
                            <table class="data-table">
                                <tr><td><strong>Avantaje</strong></td><td>Implementare foarte simplÄƒ, nu necesitÄƒ stare suplimentarÄƒ</td></tr>
                                <tr><td><strong>Dezavantaje</strong></td><td>Poate Ã®nlocui linii utile, performanÈ›Äƒ impredictibilÄƒ</td></tr>
                                <tr><td><strong>Utilizare</strong></td><td>Cache-uri L3 mari, sisteme embedded</td></tr>
                            </table>

                            <div class="info-box">
                                <p class="info-title">ğŸ’¡ ObservaÈ›ie InteresantÄƒ</p>
                                <p>
                                    SurprinzÄƒtor, pentru cache-uri cu asociativitate mare (16+ way), 
                                    Random performeazÄƒ aproape la fel de bine ca LRU, cu hardware mult mai simplu.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header">
                        <span>ğŸ”„ FIFO (First In, First Out)</span>
                        <span class="icon-plus">+</span>
                    </button>
                    <div class="accordion-content">
                        <div class="accordion-body">
                            <p class="text-content">
                                <strong>FIFO</strong> Ã®nlocuieÈ™te linia care a fost adusÄƒ Ã®n cache cel mai demult, 
                                indiferent de accesurile ulterioare.
                            </p>
                            
                            <table class="data-table">
                                <tr><td><strong>Avantaje</strong></td><td>Simplu de implementat, necesitÄƒ doar un contor circular</td></tr>
                                <tr><td><strong>Dezavantaje</strong></td><td>Nu È›ine cont de frecvenÈ›a accesurilor, poate avea anomalii</td></tr>
                                <tr><td><strong>Utilizare</strong></td><td>Mai rar folosit Ã®n cache-uri moderne</td></tr>
                            </table>

                            <div class="info-box info-blue">
                                <p class="info-title">âš ï¸ Anomalia BÃ©lÃ¡dy</p>
                                <p>
                                    FIFO poate suferi de "anomalia BÃ©lÃ¡dy": creÈ™terea dimensiunii cache-ului 
                                    poate duce uneori la <em>mai multe</em> miss-uri! AceastÄƒ anomalie nu 
                                    apare la LRU.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header">
                        <span>ğŸ“Š Pseudo-LRU (PLRU)</span>
                        <span class="icon-plus">+</span>
                    </button>
                    <div class="accordion-content">
                        <div class="accordion-body">
                            <p class="text-content">
                                <strong>Pseudo-LRU</strong> aproximeazÄƒ LRU folosind un arbore binar de biÈ›i. 
                                Este mai simplu de implementat È™i necesitÄƒ mai puÈ›inÄƒ memorie decÃ¢t LRU real.
                            </p>
                            
                            <table class="data-table">
                                <tr><td><strong>Avantaje</strong></td><td>Aproape la fel de bun ca LRU, hardware mai simplu</td></tr>
                                <tr><td><strong>Dezavantaje</strong></td><td>Nu garanteazÄƒ Ã®nlocuirea exact a LRU</td></tr>
                                <tr><td><strong>Utilizare</strong></td><td>L1/L2 Ã®n procesoare Intel È™i AMD</td></tr>
                            </table>

                            <div class="code-block">
<pre>Arbore PLRU pentru 4 cÄƒi:
         [b0]
        /    \
     [b1]    [b2]
     / \      / \
   W0  W1   W2  W3

BiÈ›ii indicÄƒ "calea recent folositÄƒ" (0=stÃ¢nga, 1=dreapta)
La Ã®nlocuire, se urmeazÄƒ calea inversÄƒ a biÈ›ilor</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-header">
                        <span>ğŸ”¢ LFU (Least Frequently Used)</span>
                        <span class="icon-plus">+</span>
                    </button>
                    <div class="accordion-content">
                        <div class="accordion-body">
                            <p class="text-content">
                                <strong>LFU</strong> Ã®nlocuieÈ™te linia care a fost accesatÄƒ de cel mai puÈ›ine ori. 
                                Se bazeazÄƒ pe ideea cÄƒ datele accesate frecvent ar trebui pÄƒstrate.
                            </p>
                            
                            <table class="data-table">
                                <tr><td><strong>Avantaje</strong></td><td>Bun pentru workload-uri cu hot spots clare</td></tr>
                                <tr><td><strong>Dezavantaje</strong></td><td>Contoare mari, nu se adapteazÄƒ la schimbÄƒri de pattern</td></tr>
                                <tr><td><strong>Utilizare</strong></td><td>Mai rar Ã®n hardware, mai comun Ã®n software (cache web)</td></tr>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="section" id="implementare-lru">
            <h2 class="section-title">Implementarea LRU</h2>
            
            <p class="text-content">
                LRU real necesitÄƒ urmÄƒrirea completÄƒ a ordinii accesurilor, ceea ce devine 
                costisitor pentru asociativitate mare:
            </p>

            <table class="data-table">
                <thead>
                    <tr>
                        <th>Asociativitate</th>
                        <th>BiÈ›i necesari</th>
                        <th>StÄƒri posibile</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td>2-way</td><td>1 bit</td><td>2</td></tr>
                    <tr><td>4-way</td><td>5 biÈ›i</td><td>24 = 4!</td></tr>
                    <tr><td>8-way</td><td>15 biÈ›i</td><td>40320 = 8!</td></tr>
                    <tr><td>16-way</td><td>44 biÈ›i</td><td>~21 Ã— 10Â¹Â²</td></tr>
                </tbody>
            </table>

            <div class="info-box">
                <p class="info-title">ğŸ’¡ De ce PLRU?</p>
                <p>
                    PLRU necesitÄƒ doar N-1 biÈ›i pentru N cÄƒi (3 biÈ›i pentru 4-way, 7 biÈ›i pentru 8-way), 
                    faÈ›Äƒ de complexitatea exponenÈ›ialÄƒ a LRU real. De aceea procesoarele moderne 
                    folosesc PLRU sau variante adaptive.
                </p>
            </div>
        </section>

        <section class="section" id="comparatie">
            <h2 class="section-title">ComparaÈ›ie de PerformanÈ›Äƒ</h2>
            
            <div class="card-grid">
                <div class="info-card">
                    <div class="card-icon">ğŸ¥‡</div>
                    <h3 class="card-title">OPT (Optimal)</h3>
                    <p class="card-text">
                        Algoritmul teoretic perfect - Ã®nlocuieÈ™te linia care va fi folositÄƒ 
                        cel mai tÃ¢rziu Ã®n viitor. Imposibil de implementat (necesitÄƒ cunoaÈ™terea viitorului), 
                        dar folosit ca referinÈ›Äƒ pentru evaluare.
                    </p>
                </div>
                <div class="info-card">
                    <div class="card-icon">ğŸ¥ˆ</div>
                    <h3 class="card-title">LRU</h3>
                    <p class="card-text">
                        Cel mai bun algoritm practic. Ãn medie, miss rate cu 1-2% mai mare decÃ¢t OPT. 
                        Folosit cÃ¢nd hardware-ul permite.
                    </p>
                </div>
                <div class="info-card">
                    <div class="card-icon">ğŸ¥‰</div>
                    <h3 class="card-title">PLRU / Random</h3>
                    <p class="card-text">
                        PerformanÈ›Äƒ apropiatÄƒ de LRU (Ã®n general < 5% diferenÈ›Äƒ) cu 
                        implementare mult mai simplÄƒ. Alegerea practicÄƒ pentru asociativitate mare.
                    </p>
                </div>
            </div>
        </section>

        <section class="section" id="sumar">
            <h2 class="section-title">Rezumat</h2>
            <div class="info-box info-green">
                <p class="info-title">ğŸ“ Puncte Cheie</p>
                <ul class="content-list">
                    <li><strong>LRU:</strong> ÃnlocuieÈ™te cel mai vechi accesat - cea mai bunÄƒ performanÈ›Äƒ</li>
                    <li><strong>Random:</strong> Alegere aleatorie - simplu, surprinzÄƒtor de eficient</li>
                    <li><strong>FIFO:</strong> Primul intrat, primul ieÈ™it - simplu dar poate avea anomalii</li>
                    <li><strong>PLRU:</strong> Aproximare a LRU cu hardware redus - folosit Ã®n practicÄƒ</li>
                    <li>Complexitatea LRU creÈ™te factorial cu asociativitatea</li>
                </ul>
            </div>
        </section>
    </article>

    <script>
        document.querySelectorAll('.accordion-header').forEach(header => {
            header.addEventListener('click', () => {
                const content = header.nextElementSibling;
                const isExpanded = content.classList.contains('expanded');
                header.classList.toggle('active', !isExpanded);
                content.classList.toggle('expanded', !isExpanded);
            });
        });
    </script>
    <script src="../../js/lesson.js"></script>
</body>
</html>
